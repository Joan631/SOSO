# shake_voice_handler.py
import math, json
from kivy.clock import Clock
from kivy.utils import platform
from plyer import gps, notification

# For Android SMS
if platform == "android":
    from jnius import autoclass

# Voice recognition imports
import pyaudio
from vosk import Model, KaldiRecognizer
import os

# --- Cross-platform accelerometer ---
if platform in ("android", "ios"):
    from plyer import accelerometer
else:
    accelerometer = None  # Disable shake on non-mobile


class ShakeVoiceHandler:
    """
    Handles shake detection (mobile only) and voice activation for SOS alerts.
    Sends alert SMS (Android) and notifications with current GPS location.
    """

    def __init__(self, app, button_settings):
        self.app = app
        self.settings = button_settings

        # --- Shake ---
        self.last_x = self.last_y = self.last_z = None
        self.shake_threshold = 10.0
        self._shake_event = None
        self._shake_count = 0
        self._required_consecutive = 2
        self.is_monitoring = False

        # --- Voice ---
        self.is_listening = False
        self._voice_event = None
        self.vosk_initialized = False
        self.p = None
        self.stream = None
        self.rec = None

        # --- GPS ---
        self.current_location = {"lat": None, "lon": None}
        self._gps_started = False
        self.start_gps()

        # Initialize Vosk if enabled
        if self.settings.get("voice_enabled", False):
            self.init_vosk()

    # ---------------- GPS ----------------
    def start_gps(self):
        """Start GPS and update current_location."""
        try:
            gps.configure(on_location=self.on_location_update)
            gps.start(minTime=1000, minDistance=0)
            self._gps_started = True
        except Exception:
            # Fallback to default location if GPS fails
            self.current_location["lat"], self.current_location["lon"] = 14.5995, 120.9842

    def on_location_update(self, **kwargs):
        """Callback from GPS updates."""
        self.current_location["lat"] = kwargs.get("lat")
        self.current_location["lon"] = kwargs.get("lon")

    def get_location(self):
        """Return current location as dict."""
        return self.current_location

    # ---------------- SHAKE ----------------
    def start_shake_monitoring(self):
        """Start monitoring device shakes (mobile only)."""
        if not accelerometer:
            print("Shake detection not supported on this platform")
            return

        try:
            accelerometer.enable()
        except Exception:
            pass

        s = int(self.settings.get("shake_sensitivity", 5))
        self.shake_threshold = max(2.0, 15.0 - (s * 1.2))
        self.last_x = self.last_y = self.last_z = None
        self._shake_count = 0
        self.is_monitoring = True

        if self._shake_event:
            self._shake_event.cancel()
        self._shake_event = Clock.schedule_interval(self.check_shake, 0.1)

    def stop_shake_monitoring(self):
        """Stop monitoring shakes."""
        self.is_monitoring = False
        if self._shake_event:
            try:
                self._shake_event.cancel()
            except Exception:
                pass
        if accelerometer:
            try:
                accelerometer.disable()
            except Exception:
                pass

    def check_shake(self, dt):
        """Check accelerometer data for shakes."""
        if not self.is_monitoring or not accelerometer:
            return

        try:
            val = accelerometer.acceleration
            if not val or any(v is None for v in val[:3]):
                return
            x, y, z = val[:3]
            if self.last_x is None:
                self.last_x, self.last_y, self.last_z = x, y, z
                return

            dx, dy, dz = x - self.last_x, y - self.last_y, z - self.last_z
            total = math.sqrt(dx*dx + dy*dy + dz*dz)
            if total > self.shake_threshold:
                self._shake_count += 1
                if self._shake_count >= self._required_consecutive:
                    self.on_shake_detected()
                    self._shake_count = 0
            else:
                self._shake_count = 0

            self.last_x, self.last_y, self.last_z = x, y, z

        except Exception as e:
            print("Shake error:", e)

    def on_shake_detected(self):
        """Triggered when shake is detected."""
        print("SHAKE DETECTED! Sending alert...")
        self.send_alert("Shake")

    # ---------------- VOSK VOICE ----------------
    def init_vosk(self):
        """Initialize Vosk voice recognition."""
        model_path = "model"
        if not os.path.exists(model_path):
            print("Vosk model missing!")
            return

        self.vosk_initialized = True
        self.model = Model(model_path)
        self.rec = KaldiRecognizer(self.model, 16000)
        self.p = pyaudio.PyAudio()
        self.stream = self.p.open(
            format=pyaudio.paInt16, channels=1, rate=16000,
            input=True, frames_per_buffer=8192
        )
        self.stream.start_stream()
        self.is_listening = True
        self._voice_event = Clock.schedule_interval(self.check_voice, 0.5)

    def check_voice(self, dt):
        """Check microphone input for activation phrase."""
        if not self.is_listening:
            return

        try:
            data = self.stream.read(4096, exception_on_overflow=False)
            if self.rec.AcceptWaveform(data):
                result = json.loads(self.rec.Result())
                text = result.get("text", "").lower()
                phrase = self.settings.get("voice_phrase", "help").lower()
                if phrase in text:
                    print("VOICE ACTIVATION DETECTED! Sending alert...")
                    self.send_alert("Voice")
        except Exception as e:
            print("Voice recognition error:", e)

    def stop_voice_listening(self):
        """Stop voice recognition."""
        self.is_listening = False
        if self._voice_event:
            try:
                self._voice_event.cancel()
            except Exception:
                pass

    # ---------------- EMERGENCY ----------------
    def send_alert(self, trigger):
        """Send emergency alert with current GPS location."""
        loc = self.get_location()
        lat, lon = loc.get("lat"), loc.get("lon")
        msg = f"EMERGENCY: {trigger} at {lat},{lon}" if lat and lon else f"EMERGENCY: {trigger} (location unknown)"
        print(msg)

        # Android SMS
        if platform == "android":
            SmsManager = autoclass('android.telephony.SmsManager').getDefault()
            for c in getattr(self.app, "emergency_contacts", []):
                phone = c.get("phone")
                if phone:
                    try:
                        SmsManager.sendTextMessage(phone, None, msg, None, None)
                        print("SMS sent to", phone)
                    except Exception as e:
                        print("SMS error:", e)

        # Desktop/mobile notification
        if notification:
            try:
                notification.notify(title="Emergency Alert", message=msg, timeout=3)
            except Exception:
                pass

    # ---------------- SETTINGS ----------------
    def update_settings(self, settings):
        """Update handler settings and start/stop monitoring as needed."""
        self.settings = settings

        # Shake
        if self.settings.get("shake_enabled", False):
            self.start_shake_monitoring()
        else:
            self.stop_shake_monitoring()

        # Voice
        if self.settings.get("voice_enabled", False):
            if not self.vosk_initialized:
                self.init_vosk()
            self.is_listening = True
        else:
            self.stop_voice_listening()
